# -*- coding: utf-8 -*-
"""1771078_정드림_멀티모달_2차_코드_모델2개.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19eTqwwP82ZAFtiG0AKuQh_UvoGCc_-Tz
"""

from glob import glob
import imageio
import cv2
import numpy as np
import pandas as pd
from PIL import Image
from google.colab import files
import imgaug.augmenters as iaa
import imgaug.imgaug

from sklearn.model_selection import train_test_split,StratifiedKFold,KFold,cross_validate
from sklearn.metrics import make_scorer, accuracy_score,recall_score,precision_score,f1_score,classification_report

import keras
from keras import backend as K
from keras import layers,optimizers,regularizers
from keras.layers import Input,Add,Dense,Activation, Flatten,Conv2D,AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D, MaxPooling2D, Dropout,ZeroPadding2D
from keras.layers.normalization import BatchNormalization
from keras.models import Model,load_model,Sequential
from keras.initializers import glorot_uniform
from keras.callbacks import EarlyStopping,ModelCheckpoint

import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers


#https://machinelearningknowledge.ai/keras-implementation-of-resnet-50-architecture-from-scratch/

import os,sys
from google.colab import drive

drive.mount('/content/mnt')

!unzip /content/mnt/MyDrive/dataset/04_multimodal_training.zip -d /content/mnt/MyDrive/dataset/multimodal_training
!unzip /content/mnt/MyDrive/dataset/04_multimodal_test.zip -d /content/mnt/MyDrive/dataset/multimodal_test

#path 정의
trainpath='/content/mnt/MyDrive/dataset/multimodal_training/'
testpath='/content/mnt/MyDrive/dataset/multimodal_test/'

#test data 숫자 길이 맞추기(0 채우기)
file_names=os.listdir(testpath)
for file_name in file_names:
  src=os.path.join(testpath,file_name)
  dst=file_name.zfill(11)
  dst=os.path.join(testpath,dst)
  os.rename(src,dst)

#face training data 불러와서 augmentation

facetraindata=glob(trainpath+'*face*')
facetraindata.sort()

faceimgheight=56
faceimgwidth=46

faceseq = iaa.Sequential([
    iaa.Fliplr(0.5),
    iaa.Multiply((0.7, 1.3)),
    iaa.Affine(
        #rotate = (-3, 3),
        translate_percent = {"x":(-0.1,0.1),"y":(-0.1,0.1)}
    )
    ])

def readFaceTrainingImages(data):
  images=[]
  for i in range(len(data)):
    img = cv2.imread(data[i])
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img,(faceimgwidth,faceimgheight))
    images.append(img)
    for j in range(3):
      img2 = faceseq.augment_image(img)
      images.append(img2)
  return images

facetrainingimages=[]
facetrainingimages=readFaceTrainingImages(facetraindata)

face_arr = np.asarray(facetrainingimages)
face_arr = face_arr.astype('float32')
face_arr=face_arr.reshape(-1,faceimgwidth,faceimgheight,3) ####
face_arr=face_arr/255
print(face_arr.shape)

#iris training data 불러와서 augmentation

iristraindata=glob(trainpath+'*iris*')
iristraindata.sort()
print(iristraindata)

irisimgheight=224
irisimgwidth=224


irisseq = iaa.Sequential([
    iaa.Fliplr(0.5),
    iaa.Flipud(0.5),
    iaa.Multiply((0.9, 1.1)),
    iaa.Affine(
        scale = (0.9,1.1),
        rotate = (-45, 45),
        translate_percent = {"x":(-0.1,0.1),"y":(-0.1,0.1)}
    )
    ])

def readIrisTrainingImages(data):
  images=[]
  for i in range(len(data)):
    img = cv2.imread(data[i])
    img=img[:,70:700]
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img,(irisimgwidth,irisimgheight))
    images.append(img)
    for j in range(3):
      img2=irisseq.augment_image(img)
      images.append(img2)
  return images

iristrainingimages=[]
iristrainingimages=readIrisTrainingImages(iristraindata)

iris_arr = np.asarray(iristrainingimages)
iris_arr = iris_arr.astype('float32')
iris_arr=iris_arr.reshape(-1,irisimgwidth,irisimgheight,3) ####
iris_arr=iris_arr/255
print(iris_arr.shape)

#face test data 가져오기(증강x)

def readFaceTestImages(data):
  images=[]
  for i in range(len(data)):
    img = cv2.imread(data[i])
    img = cv2.resize(img,(faceimgwidth,faceimgheight))
    images.append(img)
  return images

facetestdata=glob(testpath+'*face*')
facetestdata.sort()
facetestimages=[]
facetestimages=readFaceTestImages(facetestdata)

facetest_arr = np.asarray(facetestimages)
facetest_arr = facetest_arr.astype('float32')
facetest_arr=facetest_arr.reshape(-1,faceimgwidth,faceimgheight,3) ####
facetest_arr=facetest_arr/255
print(facetest_arr.shape)

#iris test data 가져오기(증강x)

def readIrisTestImages(data):
  images=[]
  for i in range(len(data)):
    img = cv2.imread(data[i])
    img=img[:,70:700]
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img,(irisimgwidth,irisimgheight))
    images.append(img)
  return images

iristestdata=glob(testpath+'*iris*')
iristestdata.sort()
iristestimages=[]
iristestimages=readIrisTestImages(iristestdata)

iristest_arr = np.asarray(iristestimages)
iristest_arr = iristest_arr.astype('float32')
iristest_arr=iristest_arr.reshape(-1,irisimgwidth,irisimgheight,3) ####
iristest_arr=iristest_arr/255
print(iristest_arr.shape)

#show face training set images

fig, axes = plt.subplots(4, 8, figsize=(20, 10), subplot_kw={'xticks':(), 'yticks':()})
for image, ax in zip(facetrainingimages, axes.ravel()):
  ax.imshow(image,cmap='gray')
plt.show()

#show face test set images

fig, axes = plt.subplots(4, 8, figsize=(20, 10), subplot_kw={'xticks':(), 'yticks':()})
for image, ax in zip(facetestimages, axes.ravel()):
  ax.imshow(image)
plt.show()

#show iris training set images

fig, axes = plt.subplots(4, 8, figsize=(20, 10), subplot_kw={'xticks':(), 'yticks':()})
for image, ax in zip(iristrainingimages, axes.ravel()):
  ax.imshow(image)
plt.show()

#show iris test set images

fig, axes = plt.subplots(4, 8, figsize=(20, 10), subplot_kw={'xticks':(), 'yticks':()})
for image, ax in zip(iristestimages, axes.ravel()):
  ax.imshow(image)
plt.show()

#train data의 label 만들기

facelabel=[]
irislabel=[]
for i in range(64):
  for j in range(16):
      #facelabel.append(i)
      irislabel.append(i)


#################
for i in range(64):
  for j in range(16):
      facelabel.append(i)
####################
print(facelabel)
print(irislabel)

facelabel_arr=np.array(facelabel)
irislabel_arr=np.array(irislabel)
print(facelabel_arr.shape)
print(irislabel_arr.shape)

#ResNet50

class conv_block(tf.keras.Model):
    def __init__(self, filters, strides=(2, 2)):
        super(conv_block, self).__init__()

        self.filters1, self.filters2, self.filters3 = filters
        self.strides = strides

        self.conv1 = tf.keras.layers.Conv2D(self.filters1, (1, 1), strides=strides)
        self.bn1 = tf.keras.layers.BatchNormalization()
        self.relu1 = tf.keras.layers.ReLU()

        self.conv2 = tf.keras.layers.Conv2D(self.filters2, (3, 3), strides=(1, 1), padding='same')
        self.bn2 = tf.keras.layers.BatchNormalization()
        self.relu2 = tf.keras.layers.ReLU()

        self.conv3 = tf.keras.layers.Conv2D(self.filters3, (1, 1), strides=(1, 1))
        self.bn3 = tf.keras.layers.BatchNormalization()

        self.shortcut_conv = tf.keras.layers.Conv2D(self.filters3, (1, 1), strides=strides)
        self.shortcut_bn = tf.keras.layers.BatchNormalization()

        self.add = tf.keras.layers.Add()
        self.add_relu = tf.keras.layers.ReLU()

    def call(self, input_tensor, training=False):
        x = self.conv1(input_tensor)
        x = self.bn1(x)
        x = self.relu1(x)

        x = self.conv2(x)
        x = self.bn2(x)
        x = self.relu2(x)

        x = self.conv3(x)
        x = self.bn3(x)

        shortcut = self.shortcut_conv(input_tensor)
        shortcut = self.shortcut_bn(shortcut)

        x = self.add([x, shortcut])
        x = self.add_relu(x)

        return x
        


class identity_block(tf.keras.Model):
    def __init__(self, filters):
        super(identity_block, self).__init__()

        self.filters1, self.filters2, self.filters3 = filters

        self.conv1 = tf.keras.layers.Conv2D(self.filters1, (1, 1), strides=(1, 1))
        self.bn1 = tf.keras.layers.BatchNormalization()
        self.relu1 = tf.keras.layers.ReLU()

        self.conv2 = tf.keras.layers.Conv2D(self.filters2, (3, 3), strides=(1, 1), padding='same')
        self.bn2 = tf.keras.layers.BatchNormalization()
        self.relu2 = tf.keras.layers.ReLU()

        self.conv3 = tf.keras.layers.Conv2D(self.filters3, (1, 1), strides=(1, 1))
        self.bn3 = tf.keras.layers.BatchNormalization()
        
        self.add = tf.keras.layers.Add()
        self.add_relu = tf.keras.layers.ReLU()

    def call(self, input_tensor, training=False):
        x = self.conv1(input_tensor)
        x = self.bn1(x)
        x = self.relu1(x)

        x = self.conv2(x)
        x = self.bn2(x)
        x = self.relu2(x)

        x = self.conv3(x)
        x = self.bn3(x)

        x = self.add([x, input_tensor])
        x = self.add_relu(x)

        return x



class ResNet50(tf.keras.Model):
    def __init__(self, nb_classes):
        super(ResNet50, self).__init__()
        self.nb_classes = nb_classes

        # Stage 1 (Conv1 Layer)
        self.zero_padd_1_1 = tf.keras.layers.ZeroPadding2D(padding=(3, 3))
        self.conv_1 = tf.keras.layers.Conv2D(64, (7, 7), strides=(2, 2))
        self.bn_1 = tf.keras.layers.BatchNormalization()
        self.relu_1 = tf.keras.layers.ReLU()
        self.zero_padd_1_2 = tf.keras.layers.ZeroPadding2D(padding=(1, 1))
        self.max_pool = tf.keras.layers.MaxPooling2D((3, 3), strides=(2, 2))
        self.avg_pool = tf.keras.layers.AveragePooling2D((3,3),strides=(2,2))

        # Stage 2
        self.stage2 = tf.keras.Sequential()
        self.stage2.add(conv_block([64, 64, 256], strides=(1, 1)))
        self.stage2.add(identity_block([64, 64, 256]))
        self.stage2.add(identity_block([64, 64, 256]))

        # Stage 3
        self.stage3 = tf.keras.Sequential()
        self.stage3.add(conv_block([128, 128, 512]))
        self.stage3.add(identity_block([128, 128, 512]))
        self.stage3.add(identity_block([128, 128, 512]))
        self.stage3.add(identity_block([128, 128, 512]))

        # Stage 4
        self.stage4 = tf.keras.Sequential()
        self.stage4.add(conv_block([256, 256, 1024]))
        self.stage4.add(identity_block([256, 256, 1024]))
        self.stage4.add(identity_block([256, 256, 1024]))
        self.stage4.add(identity_block([256, 256, 1024]))
        self.stage4.add(identity_block([256, 256, 1024]))
        self.stage4.add(identity_block([256, 256, 1024]))

        # Stage 5
        self.stage5 = tf.keras.Sequential()
        self.stage5.add(conv_block([512, 512, 2048]))
        self.stage5.add(identity_block([512, 512, 2048]))
        self.stage5.add(identity_block([512, 512, 2048]))

        self.gap = tf.keras.layers.GlobalAveragePooling2D()
        self.dense = tf.keras.layers.Dense(self.nb_classes, activation='softmax')


    def call(self, input_tensor, training=False):
        x = self.zero_padd_1_1(input_tensor)
        x = self.conv_1(x)
        x = self.bn_1(x)
        x = self.relu_1(x)
        x = self.zero_padd_1_2(x)
        x = self.max_pool(x)

        x = self.stage2(x)
        x = self.stage3(x)
        x = self.stage4(x)
        x = self.stage5(x)

        x = self.gap(x)
        x = self.dense(x)

        return x 


model1 = ResNet50(64)
model1.build((1, faceimgwidth,faceimgheight, 3))
model1.summary()

face_input = keras.Input(shape=(46, 56, 3), dtype='float32', name='face_input')
x = layers.Conv2D(32, 3, activation="relu")(face_input)
x = layers.Conv2D(64, 3, activation="relu")(x)
block_1_output = layers.MaxPooling2D(3)(x)

x = layers.Conv2D(64, 3, activation="relu", padding="same")(block_1_output)
x = layers.Conv2D(64, 3, activation="relu", padding="same")(x)
block_2_output = layers.add([x, block_1_output])

x = layers.Conv2D(64, 3, activation="relu", padding="same")(block_2_output)
x = layers.Conv2D(64, 3, activation="relu", padding="same")(x)
block_3_output = layers.add([x, block_2_output])

x = layers.Conv2D(64, 3, activation="relu")(block_3_output)
x = layers.GlobalAveragePooling2D()(x)
x = layers.Dense(256, activation="relu")(x)
x = layers.Dropout(0.5)(x)

model_output = layers.Dense(64,activation=tf.nn.softmax,name='model_output')(x)

model0 = keras.Model(inputs=face_input, outputs=model_output)
model0.summary()

'''
facemodel_path='./{epoch:02d}-val_loss:.4f}.h5'
checkpointer=ModelCheckpoint(filepath=facemodel_path, save_best_only=True, monitor=val_loss, mode=min)
'''

face_batch_size=32
face_epoch=30
face_learning_rate=0.001
model0.compile(optimizer=optimizers.RMSprop(learning_rate=face_learning_rate),
              loss='sparse_categorical_crossentropy', metrics=['acc'])

kfold = KFold(n_splits=4,shuffle=True)
i=0
for train_index, validate_index in kfold.split(face_arr,facelabel_arr):
  i+=1
  print('<',i,' step>')
  X_train, X_val = face_arr[train_index], face_arr[validate_index]
  y_train, y_val = facelabel_arr[train_index], facelabel_arr[validate_index]

  history=model0.fit(X_train,y_train,batch_size=face_batch_size,epochs=face_epoch,
                    validation_data=(X_val,y_val))

  y_pred = model0.predict(X_val, batch_size=face_batch_size, verbose=1)
  y_pred_bool = np.argmax(y_pred, axis=1)
  print(classification_report(y_val, y_pred_bool))

  epochs_range = range(face_epoch)
  plt.figure(figsize=(8, 8))
  plt.subplot(1, 2, 1)
  plt.plot(epochs_range, history.history['acc'], label='Training Accuracy')
  plt.plot(epochs_range, history.history['val_acc'], label='Validation Accuracy')
  plt.legend(loc='lower right')
  plt.title('Training and Validation Accuracy')

  plt.subplot(1, 2, 2)
  plt.plot(epochs_range, history.history['loss'], label='Training Loss')
  plt.plot(epochs_range, history.history['val_loss'], label='Validation Loss')
  plt.legend(loc='upper right')
  plt.title('Training and Validation Loss')
  plt.show()

facepredict=model0.predict(facetest_arr)
faceanswer=np.argmax(facepredict,1)
print(faceanswer)

model2=tf.keras.applications.ResNet50V2(
    include_top=True,
    input_tensor=None,
    weights=None,
    input_shape=None,
    pooling=None,
    classes=64,
    classifier_activation="softmax",
)

iris_batch_size=32
iris_epoch=20
iris_learning_rate=0.001

model2.compile(optimizer=optimizers.Adagrad(learning_rate=iris_learning_rate),
              loss='sparse_categorical_crossentropy', metrics=['acc'])
kfold = KFold(n_splits=4,shuffle=True)
i=0
for train_index, validate_index in kfold.split(iris_arr,irislabel_arr):
  i+=1
  print('<',i,' step>')
  X_train, X_val = iris_arr[train_index], iris_arr[validate_index]
  y_train, y_val = irislabel_arr[train_index], irislabel_arr[validate_index]

  history=model2.fit(X_train,y_train,batch_size=iris_batch_size,epochs=iris_epoch,
                    validation_data=(X_val,y_val))

  y_pred = model2.predict(X_val, batch_size=iris_batch_size, verbose=1)
  y_pred_bool = np.argmax(y_pred, axis=1)
  print(classification_report(y_val, y_pred_bool))

  epochs_range = range(iris_epoch)
  plt.figure(figsize=(8, 8))
  plt.subplot(1, 2, 1)
  plt.plot(epochs_range, history.history['acc'], label='Training Accuracy')
  plt.plot(epochs_range, history.history['val_acc'], label='Validation Accuracy')
  plt.legend(loc='lower right')
  plt.title('Training and Validation Accuracy')

  plt.subplot(1, 2, 2)
  plt.plot(epochs_range, history.history['loss'], label='Training Loss')
  plt.plot(epochs_range, history.history['val_loss'], label='Validation Loss')
  plt.legend(loc='upper right')
  plt.title('Training and Validation Loss')
  plt.show()

irispredict=model2.predict(iristest_arr)
irisanswer=tf.argmax(irispredict,1)
print(irisanswer)

twomodel=[]
for i in range(64):
  face_softmax=facepredict[i]
  iris_softmax=irispredict[i]
  sum_softmax=face_softmax+iris_softmax
  if np.argmax(face_softmax) == np.argmax(iris_softmax):
    twomodel.append(np.argmax(face_softmax))
  else:
    twomodel.append(np.argmax(sum_softmax))

for i in range(len(twomodel)):
  print(twomodel[i],end=' ')
  if (i+1)%10==0:
    print()

twomodeldf=pd.DataFrame(twomodel)
twomodeldf

twomodeldf.to_csv('twomodel2.txt')
files.download('twomodel2.txt')